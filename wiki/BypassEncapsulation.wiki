#labels Usage
== Bypass encapsulation ==

=== Quick summary ===

  # Use `Whitebox.setInternalState(..)` to set a private member of an instance.
  # Use `Whitebox.getInternalState(..)` to get a private member of an instance.
  # Use `Whitebox.invokeMethod(..)` to invoke a private method of an instance.
  # Use `Whitebox.invokeConstructor(..)` to create an instance of a class with a private constructor.

=== Example ===

=== Access internal state ===
For mutable objects internal state may change after a method has been invoked. When unit testing such objects it's good to have an easy way to get a hold of this state and see if it has updated accordingly. PowerMock supplies several useful reflection utilities specially designed to be used with unit testing. All of these reflection utilities are located in the `org.powermock.Whitebox` class. 

For demonstration purposes let's say we have a class that looks like this:
{{{
public class ServiceHolder {

	private final Set<Object> services = new HashSet<Object>();

	public void addService(Object service) {
		services.add(service);
	}

	public void removeService(Object service) {
		services.remove(service);
	}
}
}}}

Let's say that we'd like to test the `addService` method. Here we'd like to make sure that the state of the `ServiceHolder` has been correctly updated after the `addService` method has been invoked. I.e. a new object has been added to the `services` set. One way of doing this is to add a package-private or protected method called something like `getServices()` which returns the `services` set. But by doing this we've added a method to the `ServiceHolder` class that has no other purpose than making the class testable. This method may possibly also be miss-used elsewhere in the code. Another alternative would be to use the `Whitebox.getInternalState(..)` method in PowerMock to accomplish the same thing without altering the production code. In this simple case the whole test for the `addService` method would look like:

{{{
@Test
public void testAddService() throws Exception {
	ServiceHolder tested = new ServiceHolder();
	final Object service = new Object();

	tested.addService(service);

        // This is how you get the private services set using PowerMock
	Set<String> services = (Set<String>) Whitebox.getInternalState(tested,
			"services");

	assertEquals("Size of the \"services\" Set should be 1", 1, services
			.size());
	assertSame("The services Set should didn't contain the expect service",
			service, services.iterator().next());
}
}}}

It's just as easy to set internal state of an object. Say for example that we have the following class:
{{{
public class ReportGenerator {

	@Injectable
	private ReportTemplateService reportTemplateService;

	public Report generateReport(String reportId) {
		String templateId = reportTemplateService.getTemplateId(reportId);
		/*
		 * Imagine some other code here that generates the report based on the
		 * template id.
		 */
		return new Report("name");
	}
}
}}}

Here we imagine that we're using a dependency injection framework that automatically supply us with an instance of the `ReportTemplateService` in run-time. For testing this class we have numerous options. We could for example refactor the class to use constructor or setter injection, use java reflection or we could simply create a setter for `reportTemplateService` that should be used _only_ for test purposes (i.e. setting a mock instance). Another approach would be to let PowerMock do the reflection for you by using the `Whitebox.setInternalState(..)` method. In this case it would be really easy:
{{{
Whitebox.setInternalState(tested, "reportTemplateService", reportTemplateServiceMock);
}}}


The set and get internal state methods that we've just seen also has some slightly more advanced use cases. Many times it's useful to modify or read internal state somewhere in the class hierarchy of an object. For example suppose that we have an instance of class A that extends B and B has a field called `myPrivateString` of type `java.lang.String` whose contents we'd like to read. By using `Whitebox.getInternalState(..)` we can do this easily by specifying where in the class hierarchy the field should be read from. In this case we'd write something like:
{{{
String myPrivateString = (String) Whitebox.getInternalState(instanceOfA, "myPrivateString", B.class);
}}}

You can also choose to avoid the cast by specifying the return type:
{{{
String myPrivateString = Whitebox.getInternalState(instanceOfA, "myPrivateString", B.class, String.class);
}}}

If we instead like to set the state of the `myPrivateString` we'd do like this:
{{{
Whitebox.setInternalState(instanceOfA, "myPrivateString", "this is my private string", B.class);
}}}

Also note that in order to set the state for a [MockPartial partially mocked] object you'd also need specify the class of the object you're testing. For example let's say you have the following piece of code:
{{{
public class ReportDao {

	@Injectable
	private Cache cache;

	public void deleteReport(final String reportName) {
		Report report = getReportFromTargetName(reportName);
		cache.invalidateCache(report);
		// Imagine that we delete the report from some persistence storage.
	}

	private Report getReportFromTargetName(final String reportName) {
		/* Imagine that this method does something that many methods share */
		return null;
	}
}
}}}

Here we'd like to set the `cache` instance at the same time as we mock the `getReportFromTargetName` method. Without going into any details on how to perform [MockPartial partial mocking], the way to set the instance of `cache` must be done using: 
{{{
Whitebox.setInternalState(tested, "cache", cacheMock, ReportDao.class)
}}}
Since we've created a partial mock of the `ReportDao` class (since we'd wanted to mock the `getReportFromTargetName` method) the class under test is now actually a sub-class of `ReportDao`. This is because EasyMock creates a dynamic CGLib proxy which extends the ReportDao at run-time. So if we don't specify the `ReportDao.class` as the point in the class hierarchy where the cache field is located PowerMock will end up trying to looking for the cache field in the CGLib generated proxy where it'll obviously not find it.

=== Testing a private method ===

=== Instantiate a class with a private constructor ===

Note that all of these things can be achieved without using PowerMock, this is just normal Java reflection. However reflection requires much boiler-plate code and can be error prone and thus PowerMock provides you with these utility methods instead. PowerMock gives you a choice on whether to refactor your code and add getter/setter methods for checking/altering internal state or whether to use its utility methods to accomplish the same thing without changing the production code. It's up to you!

=== References === 
  * [http://code.google.com/p/powermock/source/browse/trunk/examples/DocumentationExamples/src/test/java/powermock/examples/finalmocking/StateFormatterTest.java StateFormatterTest]
  * [http://code.google.com/p/powermock/source/browse/trunk/examples/DocumentationExamples/src/main/java/powermock/examples/finalmocking/StateFormatter.java StateFormatter]
  * [http://code.google.com/p/powermock/source/browse/trunk/examples/DocumentationExamples/src/main/java/powermock/examples/finalmocking/StateHolder.java StateHolder]