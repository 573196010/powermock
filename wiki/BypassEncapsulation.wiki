#labels Usage
== Bypass encapsulation ==

=== Quick summary ===

  # Use `Whitebox.setInternalState(..)` to set a private member of an instance.
  # Use `Whitebox.getInternalState(..)` to get a private member of an instance.
  # Use `Whitebox.invokeMethod(..)` to invoke a private method of an instance.
  # Use `Whitebox.invokeConstructor(..)` to create an instance of a class with a private constructor.

=== Example ===

=== Access internal state ===
For mutable objects internal state may change after a method has been invoked. When unit testing such objects it's good to have an easy way to get a hold of this state and see if it has updated accordingly. PowerMock supplies several useful reflection utilities specially designed to be used with unit testing. All of these reflection utilities are located in the `org.powermock.Whitebox` class. 

For demonstration purposes let's say we have a class that looks like this:
{{{
public class ServiceHolder {

	private final Set<Object> services = new HashSet<Object>();

	public void addService(Object service) {
		services.add(service);
	}

	public void removeService(Object service) {
		services.remove(service);
	}
}
}}}

Let's say that we'd like to test the `addService` method. Here we'd like to make sure that the state of the `ServiceHolder` has been correctly updated after the `addService` method has been invoked. I.e. a new object has been added to the `services` set. One way of doing this is to add a package-private or protected method called something like `getServices()` which returns the `services` set. But by doing this we've added a method to the `ServiceHolder` class that has no other purpose than making the class testable. This method may possibly also be miss-used elsewhere in the code. Another alternative would be to use the `Whitebox.getInternalState(..)` method in PowerMock to accomplish the same thing without altering the production code. In this simple case the whole test for the `addService` method would look like:

{{{
@Test
public void testAddService() throws Exception {
	ServiceHolder tested = new ServiceHolder();
	final Object service = new Object();

	tested.addService(service);

        // This is how you get the private services set using PowerMock
	Set<String> services = (Set<String>) Whitebox.getInternalState(tested,
			"services");

	assertEquals("Size of the \"services\" Set should be 1", 1, services
			.size());
	assertSame("The services Set should didn't contain the expect service",
			service, services.iterator().next());
}
}}}

It's just as easy to set internal state of an object. Say for example that we have the following class:
{{{
public class ReportGenerator {

	@Injectable
	private ReportTemplateService reportTemplateService;

	public Report generateReport(String reportId) {
		String templateId = reportTemplateService.getTemplateId(reportId);
		/*
		 * Imagine some other code here that generates the report based on the
		 * template id.
		 */
		return new Report("name");
	}
}
}}}

Here we imagine that we're using a dependency injection framework that automatically supply us with an instance of the `ReportTemplateService` in run-time. For testing this class we have numerous options. We could for example refactor the class to use constructor or setter injection, use java reflection or we could simply create a setter for `reportTemplateService` that should be used _only_ for test purposes (i.e. setting a mock instance). Another approach would be to let PowerMock do the reflection for you by using the `Whitebox.setInternalState(..)` method. In this case it would be really easy:
{{{
Whitebox.setInternalState(tested, "reportTemplateService", reportTemplateServiceMock);
}}}


The set and get internal state methods that we've just seen also has some slightly more advanced use cases. Many times it's useful to modify or read internal state somewhere in the class hierarchy of an object. For example suppose that we have an instance of class A that extends B and B has a field called `myPrivateString` of type `java.lang.String` whose contents we'd like to read. By using `Whitebox.getInternalState(..)` we can do this easily by specifying where in the class hierarchy the field should be read from. In this case we'd write something like:
{{{
String myPrivateString = (String) Whitebox.getInternalState(instanceOfA, "myPrivateString", B.class);
}}}

You can also choose to avoid the cast by specifying the return type:
{{{
String myPrivateString = Whitebox.getInternalState(instanceOfA, "myPrivateString", B.class, String.class);
}}}

If we instead like to set the state of the `myPrivateString` we'd do like this:
{{{
Whitebox.setInternalState(instanceOfA, "myPrivateString", "this is my private string", B.class);
}}}

Also note that in order to set the state for a [MockPartial partially mocked] object you'd also need specify the class of the object you're testing. For example let's say you have the following piece of code:
{{{
public class ReportDao {

	@Injectable
	private Cache cache;

	public void deleteReport(final String reportName) {
		Report report = getReportFromTargetName(reportName);
		cache.invalidateCache(report);
		// Imagine that we delete the report from some persistence storage.
	}

	private Report getReportFromTargetName(final String reportName) {
		/* Imagine that this method does something that many methods share */
		return null;
	}
}
}}}

Here we'd like to set the `cache` instance at the same time as we mock the `getReportFromTargetName` method. Without going into any details on how to perform [MockPartial partial mocking], the way to set the instance of `cache` must be done using: 
{{{
Whitebox.setInternalState(tested, "cache", cacheMock, ReportDao.class)
}}}
This is because the class under test is now actually a sub-class of `ReportDao` because EasyMock creates a dynamic CGLib proxy which extends the ReportDao at run-time. So if we don't specify the `ReportDao.class` as the point in the class hierarchy where the cache field is located PowerMock will end up trying to looking for the cache field in the CGLib generated proxy where it'll obviously not find it.

=== Invoking a private method ===
To invoke a private method you can make use of the `Whitebox.invokeMethod(..)` method in PowerMock. For example let's say you have a private method called sum in class `MyClass` which you'd like to test in separation:
{{{
private int sum(int a, int b) {
	return a+b;
}
}}}
To do this you simply do: 
{{{
int sum = (Integer) Whitebox.invokeMethod(MyClass.class, "sum", 1, 2);
}}}
Printing the sum would then of course display 3. 

This will work fine in most situations. However there are cases when PowerMock cannot figure out which method to invoke by using this simple syntax. For example if an overloaded method is using a primitive type and the other method is using a wrapper type such as:
{{{
...
private int myMethod(int id) {		
	return 2*id;
}

private int myMethod(Integer id) {		
		return 3*id;
}
...
}}}

This is of course a naive example but you could still use `Whitebox.invokeMethod(..)` to call both these methods. For the `myMethod(int id)` case you'd do like this: 
{{{
int result = (Integer) Whitebox.invokeMethod(MyClass.class, new Class<?>[]{int.class}, "myMethod", 1);
}}}

Here we explicitly tell PowerMock to expect the call to the `myMethod` that takes an `int` as parameter. But in the majority of cases you don't need to specify the parameter type since PowerMock will find the correct method automatically.


=== Instantiate a class with a private constructor ===

=== Note ===
Note that all of these things can be achieved without using PowerMock, this is just normal Java reflection. However reflection requires much boiler-plate code and can be error prone and thus PowerMock provides you with these utility methods instead. PowerMock gives you a choice on whether to refactor your code and add getter/setter methods for checking/altering internal state or whether to use its utility methods to accomplish the same thing without changing the production code. It's up to you!

=== References === 
  * [http://code.google.com/p/powermock/source/browse/trunk/examples/DocumentationExamples/src/test/java/powermock/examples/finalmocking/StateFormatterTest.java StateFormatterTest]
  * [http://code.google.com/p/powermock/source/browse/trunk/examples/DocumentationExamples/src/main/java/powermock/examples/finalmocking/StateFormatter.java StateFormatter]
  * [http://code.google.com/p/powermock/source/browse/trunk/examples/DocumentationExamples/src/main/java/powermock/examples/finalmocking/StateHolder.java StateHolder]