#labels Usage
== Mocking private methods ==

=== Quick summary ===

  # Use the `@RunWith(PowerMockRunner.class)` annotation at the class-level of the test case.
  # Use the `@PrepareForTest(ClassWithPrivateMethod.class)` annotation at the class-level of the test case.
  # Use `PowerMock.mockMethod(ClassWithPrivateMethod.class, "nameOfTheMethodToMock")` to create a mock object that _only_ mocks the method with name `nameOfTheMethodToMock` in this class (let's call it `mockObject`).
  # Use `PowerMock.expectPrivate(mockObject, "nameOfTheMethodToMock", argument1, argument2)` to expect the method call to `nameOfTheMethodToMock` with arguments `argument1` and `argument2`.
  # Use `PowerMock.replay(mockObject)` to change the mock object to replay mode.
  # Use `PowerMock.verify(mockObject)` to change the mock object to verify mode.

=== Example ===

Assume that you have a class called `DataService` that you like to unit test which looks like this: 
{{{
public class DataService {

	public boolean replaceData(final String dataId, final byte[] binaryData) {
		return modifyData(dataId, binaryData);
	}

	public boolean deleteData(final String dataId) {
		return modifyData(dataId, null);
	}

	/**
	 * Modify the data.
	 * 
	 * @param dataId
	 *            The ID of the data slot where the binary data will be stored.
	 * @param binaryData
	 *            The binary data that will be stored. If <code>null</code>
	 *            this means that the data for the particular slot is considered
	 *            removed.
	 * @return <code>true</code> if the operation was successful,
	 *         <code>false</code> otherwise.
	 */
	private boolean modifyData(final String dataId, final byte[] binaryData) {
		/*
		 * Imagine this method doing something complex and expensive.
		 */
		return true;
	}
}
}}}

`DataService` has two public methods that both calls a private method called `modifyData`. This method does something that you indeed want to unit test (see the  [BypassEncapsulation bypass encapsulation] section for information on how to test private methods) but only once. You don't want to duplicate the expectation and verification behavior for the logic performed inside the `modifyData` method when testing the `replaceData` and `deleteData` methods. One way to do this is by [MockPartial partially mocking] the `DataService` class in combination with setting up the correct expectation for the `modifyData` method. PowerMock can assist you with both.

So we begin by creating a partial mock of the `DataService` class where we specify that only the `modifyData` method should be mocked, all other methods will behave as though they are not mocked. This is easily done using:
{{{
PowerMock.mockMethod(DataService.class, "modifyData");
}}}

Let's say that we're writing a test case for the `replaceData` method and thus we need to expect the method invocation to `modifyData` so that we can test it in separation. 

Note that you need to tell PowerMock which classes you like to mock. This is done by adding the `@PrepareForTest` annotation to the class-level of test case, in this case `@PrepareForTest(StateHolder.class)`. You also need to tell JUnit to execute the test using PowerMock which is done by using the `@RunWith(PowerMockRunner.class)` annotation. Without these two annotations the test will fail. 

See the partial mocking section for information on how to mock only specific methods of a class. 

=== References === 
  * [http://code.google.com/p/powermock/source/browse/trunk/examples/DocumentationExamples/src/test/java/powermock/examples/finalmocking/StateFormatterTest.java StateFormatterTest]
  * [http://code.google.com/p/powermock/source/browse/trunk/examples/DocumentationExamples/src/main/java/powermock/examples/finalmocking/StateFormatter.java StateFormatter]
  * [http://code.google.com/p/powermock/source/browse/trunk/examples/DocumentationExamples/src/main/java/powermock/examples/finalmocking/StateHolder.java StateHolder]