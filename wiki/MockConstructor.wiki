#labels Usage
== Mock construction of new classes ==

=== Quick summary ===

  # Use the `@RunWith(PowerMockRunner.class)` annotation at the class-level of the test case.
  # Use the `@PrepareForTest({ClassThatCreatesTheNewInstance.class, NewInstanceClass.class})` annotation at the class-level of the test case.
  # Use `PowerMock.createMock(NewInstanceClass.class)` to create a mock object of the class that should be constructed (let's call it `mockObject`).
  # Use `PowerMock.expectNew(NewInstanceClass.class).andReturn(mockObject)` to expect a new construction of an object of type `NewInstanceClass.class` but instead return the mock object.
  # Use `PowerMock.replay(mockObject, NewInstanceClass.class)` to change the mock object and class to replay mode.
  # Use `PowerMock.verify(mockObject, NewInstanceClass.class)` to change the mock object and class to verify mode.

=== Example ===
Let's say you have a class like this:
{{{
public class PersistenceManager {

	public boolean createDirectoryStructure(String directoryPath) {
		File directory = new File(directoryPath);

		if (directory.exists()) {
			throw new IllegalArgumentException("\"" + directoryPath + "\" already exists.");
		}

		return directory.mkdirs();
	}
}
}}}

What's interesting here is the creation of a new File object. This is interesting because in order to get 100% code coverage of this method we need to be able test the method both when the `directory.exists()` query return `true` and `false`. But in order to unit test this method one needs to substitute the File object created in this method for a mock implementation. One way to do this is to extract the call to `new File(..)` to a package private method which is overridden in the test to return a File mock. But with PowerMock you don't have to change the code, instead you can instruct PowerMock to intercept the call to `new File(..)` and return a mock object instead. To do this we start by creating a mock of type File.class as usually:
{{{
File fileMock = createMock(File.class);
}}}
To expect the call to new File we simply do: 
{{{
expectNew(File.class).andReturn(fileMock);
}}}

That's it when it comes to the expectation behavior! There are however some things that must be explained further. First of all you to tell PowerMock which classes to mock, in this case it's the File.class. But for `expectNew` this is not enough. PowerMock also needs to know which class that does the actual `new` call, in this case it's the `PersistenceManager` class that does `new File(..)`. So in order to provide PowerMock with this information we add `@PrepareForTest({PersistenceManager.class, File.class})` at the class-level of test case. As usually you also need to tell JUnit to execute the test using PowerMock which is done by using the `@RunWith(PowerMockRunner.class)` annotation. Without these two annotations the test will fail!

The last aspect is the replay and verify behavior. In order to correctly replay the expected behavior we need to replay both the `fileMock` object and the File class. I.e.
{{{
replay(fileMock, File.class);
}}}
The verification procedure is follows the same rules:
{{{
verify(fileMock, File.class);
}}}
That's it!

=== References === 
  * [http://code.google.com/p/powermock/source/browse/trunk/examples/DocumentationExamples/src/test/java/powermock/examples/newmocking/PersistenceManagerTest.java PersistenceManagerTest]
  * [http://code.google.com/p/powermock/source/browse/trunk/examples/DocumentationExamples/src/main/java/powermock/examples/newmocking/PersistenceManager.java PersistenceManager]
  * [http://code.google.com/p/powermock/source/browse/trunk/examples/DocumentationExamples/src/main/java/powermock/examples/finalmocking/StateHolder.java StateHolder]